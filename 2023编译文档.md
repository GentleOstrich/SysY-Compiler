# 2023编译文档

## 参考编译器介绍

## 编译器总体设计

### 总体结构

由三部分组成：前端、中端、后端。

前端：负责词法分析与语法分析，产生语法树。同时负责词法错误处理和语法错误处理。

中端：遍历语法树，生成LLVM中间代码。同时负责符号表管理与语义错误处理。

后端：按照LLVM的结构，遍历中间代码，生成MIPS目标代码。

### 接口设计

#### 前端

读入源程序，返回语法树。其中词法分析器Lexer为语法分析器Parser提供读取下一个token的接口。

#### 中端

读入前端生成语法树，返回LLVM的module。

#### 后端

读入中端生成的LLVM-module，生成MIPS目标代码。

### 文件组织

<ul>
  <li>Frontend</li>
    <ul>
      <li>Lexer</li>
      <li>Parser</li>
      <li>NonterminalCharacter</li>
    </ul>
  <li>IR</li>
    <ul>
      <li>SymbolManager</li>
      <li>Values</li>
      <ul>
        <li>Instructions</li>
      </ul>
    </ul>
    <li>Backend</li>
    <ul>
      <li>MipsInstructions</li>
    </ul>
</ul>

## 词法分析设计

### 编码前的设计

词法分析器Lexer通过next函数返回下一个token的名字和类型。

### 编码完成之后的修改

增加两个函数，nnext和nnnext，通过它们预读取下两个和下三个token的信息，在语法分析生成语法树阶段会用到这两个函数。

## 语法分析设计

### 编码前的设计

调用词法分析器Lexer提供的next接口，获得当前token的信息。根据文法规则、当前token的信息、调用Lexer相应接口预读到的token信息，对解析哪个语法树非终结符进行判断。

### 编码完成之后的修改

对每个非终结符建类，这些非终结符和终结符作为语法树的结点，通过指针连接，生成语法树。

## 错误处理设计

错误处理涉及词法错误、语法错误、语义错误，如下：

<table>
<thead>
<tr>
<th>错误类型</th>
<th>错误类别码</th>
<th>解释</th>
<th>对应文法及出错符号<br>( … 表示省略该条规则后续部分)</th>
</tr>
</thead>
<tbody>
<tr>
<td>非法符号</td>
<td>a</td>
<td>格式字符串中出现非法字符报错行号为 <strong>&lt;FormatString&gt;</strong> 所在行数。</td>
<td>&lt;FormatString&gt; → ‘“‘{&lt;Char&gt;}’”</td>
</tr>
<tr>
<td>名字重定义</td>
<td>b</td>
<td>函数名或者变量名在<strong>当前作用域</strong>下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 <strong>&lt;Ident&gt;</strong> 所在行数。</td>
<td>&lt;ConstDef&gt;→&lt;Ident&gt; … <br>&lt;VarDef&gt;→&lt;Ident&gt; … &lt;Ident&gt; … <br>&lt;FuncDef&gt;→&lt;FuncType&gt;&lt;Ident&gt; …<br>&lt;FuncFParam&gt; → &lt;BType&gt; &lt;Ident&gt; …</td>
</tr>
<tr>
<td>未定义的名字</td>
<td>c</td>
<td>使用了未定义的标识符报错行号为 <strong>&lt;Ident&gt;</strong> 所在行数。</td>
<td>&lt;LVal&gt;→&lt;Ident&gt; …<br>&lt;UnaryExp&gt;→&lt;Ident&gt; …</td>
</tr>
<tr>
<td>函数参数个数不匹配</td>
<td>d</td>
<td>函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。</td>
<td>&lt;UnaryExp&gt;→&lt;Ident&gt;‘(’[&lt;FuncRParams&gt;]‘)’</td>
</tr>
<tr>
<td>函数参数类型不匹配</td>
<td>e</td>
<td>函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。</td>
<td>&lt;UnaryExp&gt;→&lt;Ident&gt;‘(’[&lt;FuncRParams&gt;]‘)’</td>
</tr>
<tr>
<td>无返回值的函数存在不匹配的return语句</td>
<td>f</td>
<td>报错行号为 <strong>‘return’</strong> 所在行号。</td>
<td>&lt;Stmt&gt;→‘return’ {‘[’&lt;Exp&gt;’]’}‘;’</td>
</tr>
<tr>
<td>有返回值的函数缺少return语句</td>
<td>g</td>
<td>只需要考虑函数末尾是否存在return语句，<strong>无需考虑数据流</strong>。报错行号为函数<strong>结尾的’}’</strong> 所在行号。</td>
<td>&lt;FuncDef&gt; → &lt;FuncType&gt; &lt;Ident&gt; ‘(’ [&lt;FuncFParams&gt;] ‘)’ &lt;Block&gt;<br>&lt;MainFuncDef&gt; → ‘int’ ‘main’ ‘(’ ‘)’ &lt;Block&gt;</td>
</tr>
<tr>
<td>不能改变常量的值</td>
<td>h</td>
<td>&lt;LVal&gt;为常量时，不能对其修改。报错行号为 <strong>&lt;LVal&gt;</strong> 所在行号。</td>
<td>&lt;Stmt&gt;→&lt;LVal&gt;‘=’ &lt;Exp&gt;‘;’<br>&lt;Stmt&gt;→&lt;LVal&gt;‘=’ ‘getint’ ‘(’ ‘)’ ‘;’</td>
</tr>
<tr>
<td>缺少分号</td>
<td>i</td>
<td>报错行号为分号<strong>前一个非终结符</strong>所在行号。</td>
<td>&lt;Stmt&gt;,&lt;ConstDecl&gt;及&lt;VarDecl&gt;中的’;’</td>
</tr>
<tr>
<td>缺少右小括号’)’</td>
<td>j</td>
<td>报错行号为右小括号<strong>前一个非终结符</strong>所在行号。</td>
<td>函数调用(&lt;UnaryExp&gt;)、函数定义(&lt;FuncDef&gt;)及&lt;Stmt&gt;中的’)’</td>
</tr>
<tr>
<td>缺少右中括号’]’</td>
<td>k</td>
<td>报错行号为右中括号<strong>前一个非终结符</strong>所在行号。</td>
<td>数组定义(&lt;ConstDef&gt;,&lt;VarDef&gt;,&lt;FuncFParam&gt;)和使用(&lt;LVal&gt;)中的’]’</td>
</tr>
<tr>
<td>printf中格式字符与表达式个数不匹配</td>
<td>l</td>
<td>报错行号为 <strong>‘printf’</strong> 所在行号。</td>
<td>&lt;Stmt&gt; →‘printf’‘(’&lt;FormatString&gt;{,&lt;Exp&gt;}’)’‘;’</td>
</tr>
<tr>
<td>在非循环块中使用break和continue语句</td>
<td>m</td>
<td>报错行号为 <strong>‘break’</strong> 与 <strong>’continue’</strong> 所在行号。</td>
<td>&lt;Stmt&gt;→‘break’‘;’<br>&lt;Stmt&gt;→‘continue’‘;’</td>
</tr>
</tbody>
</table>

### 编码前的设计

词法错误（a）：在Lexer中对格式字符串进行检查。

语法错误（i j k g）：在语法分析器Parser中对缺少; ) ]进行检查。（注：j其实也应属于语义错误，但鉴于题目要求只需考虑函数结尾的语句，故将其置于Parser中处理，这样更为便捷）

语义错误（b c d e f h i）：在语义分析器Visitor中，建立符号表，结合符号表进行名字重定义等语义错误的检查与处理。

编码前没有充分理解LLVM结构，将语义分析与语法错误程序混合在一起，进行一边处理，一边生成符号表，并进行语义错误检查与处理。

### 编码完成之后的修改

词法错误和语法错误的处理方式没有变化。

语义处理中，符号类及符号表：因为LLVM的value类中记录了近乎全面的语义信息，所以结合LLVM的value类建立符号类，生成符号表。并在Vistor中结合符号表进行语义分析。





## 代码生成设计

### 编码前的设计



### 编码完成之后的修改

